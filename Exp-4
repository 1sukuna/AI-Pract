Best-First Search in Prolog

Experiment_no_1_to_5_Ai[1]

edge(a,b). edge(a,c). edge(b,d). edge(b,e). edge(c,f).
edge(e,f). edge(d,g). edge(f,g).

heuristic(a,4). heuristic(b,2). heuristic(c,4).
heuristic(d,2). heuristic(e,2). heuristic(f,1). heuristic(g,0).

best_first(Start, Goal, Path) :-
    bfs([[Start]], Goal, Path).

bfs([[Goal|Rest]|_], Goal, Path) :-
    reverse([Goal|Rest], Path).

bfs([CurrentPath|OtherPaths], Goal, Path) :-
    CurrentPath = [CurrentNode|_],
    findall([Next,CurrentNode|CurrentPath],
        (edge(CurrentNode, Next), \+ member(Next, CurrentPath)),
        NewPaths),
    sort_paths_by_heuristic(NewPaths, SortedNewPaths),
    append(OtherPaths, SortedNewPaths, UpdatedQueue),
    bfs(UpdatedQueue, Goal, Path).

sort_paths_by_heuristic(Paths, Sorted) :-
    sort_paths_by_heuristic(Paths, [], Sorted).
sort_paths_by_heuristic([], Acc, Acc).
sort_paths_by_heuristic(Paths, Acc, Sorted) :-
    select_min_path(Paths, MinPath, RestPaths),
    sort_paths_by_heuristic(RestPaths, [MinPath|Acc], Sorted).

select_min_path([P], P, []).
select_min_path([P1,P2|Rest], Min, [Other|RestPaths]) :-
    P1 = [N1|_], P2 = [N2|_],
    heuristic(N1, H1), heuristic(N2, H2),
    (H1 =< H2 -> Min=P1, Other=P2 ; Min=P2, Other=P1),
    append(Rest, [], RestPaths).

:- initialization(main).
main :-
    Start = a,
    Goal = g,
    (best_first(Start, Goal, Path) ->
        write('Best-First Search Path: '), write(Path), nl ;
        write('No path found.'), nl),
    halt.

INPUT:

(NONE)

2. Best-First Search in Python

Experiment_no_1_to_5_Ai[1]

graph = {
    'A': ['B', 'C'],
    'B': ['D', 'E'],
    'C': ['F'],
    'D': ['G'],
    'E': ['F'],
    'F': ['G'],
    'G': []
}

heuristic = {
    'A': 4, 'B': 2, 'C': 4,
    'D': 2, 'E': 2, 'F': 1, 'G': 0
}

def best_first_search(graph, start, goal, heuristic):
    from queue import PriorityQueue
    pq = PriorityQueue()
    pq.put((heuristic[start], [start]))

    while not pq.empty():
        _, path = pq.get()
        node = path[-1]
        if node == goal:
            return path
        for neighbor in graph[node]:
            if neighbor not in path:
                new_path = path + [neighbor]
                pq.put((heuristic[neighbor], new_path))
    return None

if __name__ == "__main__":
    start_node = 'A'
    goal_node = 'G'
    path = best_first_search(graph, start_node, goal_node, heuristic)
    print(path)
